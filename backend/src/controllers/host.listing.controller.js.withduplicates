// ==========================================
// HOST LISTING CONTROLLER - UPDATED WITH 24-HOUR SUPPORT
// ==========================================
// File: controllers/host.listing.controller.js
//
// Changes:
// - Added is24Hours support in operating hours
// - Added normalizeOperatingHours for data consistency
// - Updated default operating hours structure
// ==========================================

import { prisma } from "../config/prisma.config.js";
import { uploadToCloudinary, deleteFromCloudinary } from "../config/cloudinary.config.js";

// ==========================================
// OPERATING HOURS HELPERS
// ==========================================

/**
 * Default operating hours structure
 */
const DEFAULT_OPERATING_HOURS = {
  monday: { start: "09:00", end: "21:00", closed: false, is24Hours: false },
  tuesday: { start: "09:00", end: "21:00", closed: false, is24Hours: false },
  wednesday: { start: "09:00", end: "21:00", closed: false, is24Hours: false },
  thursday: { start: "09:00", end: "21:00", closed: false, is24Hours: false },
  friday: { start: "09:00", end: "21:00", closed: false, is24Hours: false },
  saturday: { start: "09:00", end: "21:00", closed: false, is24Hours: false },
  sunday: { start: "09:00", end: "21:00", closed: false, is24Hours: false },
};

/**
 * Normalize and validate operating hours data
 * Ensures consistent structure and handles edge cases
 * 
 * @param {Object} operatingHours - Raw operating hours from request
 * @returns {Object} Normalized operating hours
 */
const normalizeOperatingHours = (operatingHours) => {
  if (!operatingHours || typeof operatingHours !== "object") {
    return { ...DEFAULT_OPERATING_HOURS };
  }

  const days = ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"];
  const normalized = {};

  for (const day of days) {
    const dayData = operatingHours[day];

    if (!dayData) {
      normalized[day] = { ...DEFAULT_OPERATING_HOURS[day] };
      continue;
    }

    // Normalize the day data
    normalized[day] = {
      start: dayData.start || "09:00",
      end: dayData.end || "21:00",
      closed: Boolean(dayData.closed),
      is24Hours: Boolean(dayData.is24Hours),
    };

    // Ensure mutual exclusivity: closed takes precedence over is24Hours
    if (normalized[day].closed) {
      normalized[day].is24Hours = false;
    }

    // If 24 hours, normalize times to 00:00
    if (normalized[day].is24Hours && !normalized[day].closed) {
      normalized[day].start = "00:00";
      normalized[day].end = "00:00";
    }

    // Validate time format (HH:MM)
    const timeRegex = /^([01]\d|2[0-3]):([0-5]\d)$/;
    if (!timeRegex.test(normalized[day].start)) {
      normalized[day].start = "09:00";
    }
    if (!timeRegex.test(normalized[day].end)) {
      normalized[day].end = "21:00";
    }
  }

  return normalized;
};

/**
 * Validate operating hours for logical consistency
 * 
 * @param {Object} operatingHours - Operating hours to validate
 * @returns {{ valid: boolean, errors: string[] }}
 */
const validateOperatingHours = (operatingHours) => {
  const errors = [];
  const days = ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"];

  for (const day of days) {
    const dayData = operatingHours[day];
    
    if (!dayData) continue;

    // Skip validation for closed or 24-hour days
    if (dayData.closed || dayData.is24Hours) continue;

    // Check that end time is after start time
    const [startH, startM] = dayData.start.split(":").map(Number);
    const [endH, endM] = dayData.end.split(":").map(Number);
    const startMinutes = startH * 60 + startM;
    const endMinutes = endH * 60 + endM;

    if (endMinutes <= startMinutes) {
      errors.push(`${day}: End time must be after start time`);
    }
  }

  return {
    valid: errors.length === 0,
    errors,
  };
};

// ==========================================
// SLUG GENERATION
// ==========================================

const generateSlug = (title) => {
  return title
    .toLowerCase()
    .replace(/[^\w\s-]/g, '')
    .replace(/\s+/g, '-')
    .replace(/-+/g, '-')
    .trim()
    + '-' + Date.now();
};

// ==========================================
// IMAGE UPLOAD
// ==========================================

export const uploadImages = async (req, res) => {
  try {
    const listingId = parseInt(req.params.id);
    const hostId = Number(req.user.userId);

    if (!req.files || req.files.length === 0) {
      return res.status(400).json({ error: "No images uploaded" });
    }

    const uploadedImages = [];

    for (let i = 0; i < req.files.length; i++) {
      const file = req.files[i];

      const { secure_url, public_id } = await uploadToCloudinary(file, null, listingId);

      const isCover = i === 0;

      const image = await prisma.image.create({
        data: {
          listingId,
          url: secure_url,
          publicId: public_id,
          isCover,
        },
      });

      uploadedImages.push(image);
    }

    res.status(201).json({
      message: "Images uploaded successfully",
      images: uploadedImages,
    });
  } catch (error) {
    console.error("UPLOAD IMAGES ERROR:", error);
    res.status(500).json({ error: error.message });
  }
};

// ==========================================
// CREATE LISTING
// ==========================================

export const createListing = async (req, res) => {
  try {
    const {
      title,
      description,
      location,
      status,
      hourlyRate,
      minHours,
      maxHours,
      amenities,
      capacity,
      operatingHours,
      address,
      includedGuests,
      extraGuestCharge,
      minCapacity,
      size,
      rules,
      featured,
    } = req.body;

    const hostId = req.user.userId;

    // Validate required fields
    if (!title) {
      return res.status(400).json({ error: "Title is required" });
    }
    if (!location) {
      return res.status(400).json({ error: "Location is required" });
    }
    if (!hourlyRate) {
      return res.status(400).json({ error: "Hourly rate is required" });
    }
    if (!capacity) {
      return res.status(400).json({ error: "Capacity is required" });
    }

    // Normalize and validate operating hours
    const normalizedOperatingHours = normalizeOperatingHours(operatingHours);
    const validation = validateOperatingHours(normalizedOperatingHours);

    if (!validation.valid) {
      return res.status(400).json({
        error: "Invalid operating hours",
        details: validation.errors,
      });
    }

    // Generate slug
    const slug = generateSlug(title);

    // Prepare listing data
    const listingData = {
      title,
      slug,
      location,
      hourlyRate: parseFloat(hourlyRate),
      capacity: parseInt(capacity),
      description: description || "",
      address: address || null,
      includedGuests: includedGuests ? parseInt(includedGuests) : 10,
      extraGuestCharge: extraGuestCharge ? parseFloat(extraGuestCharge) : null,
      minCapacity: minCapacity ? parseInt(minCapacity) : 1,
      size: size || null,
      minHours: minHours ? parseInt(minHours) : 1,
      maxHours: maxHours ? parseInt(maxHours) : 12,
      status: status || "ACTIVE",
      featured: featured || false,
      views: 0,
      amenities: amenities || [],
      rules: rules || [],
      operatingHours: normalizedOperatingHours,
      host: {
        connect: { id: hostId },
      },
    };

    const listing = await prisma.listing.create({
      data: listingData,
      include: {
        images: true,
        host: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
      },
    });

    res.status(201).json(listing);
  } catch (error) {
    console.error("Create listing error:", error.message);

    if (error.code === "P2002") {
      const field = error.meta?.target?.[0];
      if (field === "slug") {
        return res.status(400).json({
          error: "A listing with this title already exists. Please try a different title.",
        });
      }
    }

    res.status(400).json({
      error: error.message,
      details: process.env.NODE_ENV === "development" ? error : undefined,
    });
  }
};

// ==========================================
// GET HOST LISTINGS
// ==========================================

export const getHostListings = async (req, res) => {
  try {
    const hostId = Number(req.user.userId);

    const listings = await prisma.listing.findMany({
      where: { hostId },
      include: {
        images: true,
        _count: {
          select: { bookings: true },
        },
        host: {
          select: {
            id: true,
            name: true,
            hostStory: {
              select: {
                id: true,
                status: true,
                storyTitle: true,
              },
            },
          },
        },
      },
      orderBy: { createdAt: "desc" },
    });

    res.json(listings);
  } catch (error) {
    console.error("GET HOST LISTINGS ERROR:", error);
    res.status(500).json({ error: error.message });
  }
};

// ==========================================
// GET LISTING BY ID
// ==========================================

export const getListingById = async (req, res) => {
  try {
    const { id } = req.params;
    const hostId = req.user.userId;

    const listing = await prisma.listing.findFirst({
      where: {
        id: parseInt(id),
        hostId,
      },
      include: {
        images: true,
        host: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
      },
    });

    if (!listing) {
      return res.status(404).json({ error: "Listing not found" });
    }

    res.json(listing);
  } catch (error) {
    console.error("GET LISTING BY ID ERROR:", error);
    res.status(500).json({ error: error.message });
  }
};

// ==========================================
// UPDATE LISTING
// ==========================================

export const updateListing = async (req, res) => {
  try {
    const { id } = req.params;
    const hostId = Number(req.user.userId);
    const {
      title,
      description,
      location,
      status,
      hourlyRate,
      minHours,
      maxHours,
      amenities,
      capacity,
      operatingHours,
      address,
      includedGuests,
      extraGuestCharge,
      minCapacity,
      size,
      rules,
    } = req.body;

    // Check ownership
    const existing = await prisma.listing.findFirst({
      where: { id: parseInt(id), hostId },
    });

    if (!existing) {
      return res.status(404).json({ error: "Listing not found" });
    }

    // Build update data (only include provided fields)
    const updateData = {};

    if (title !== undefined) updateData.title = title;
    if (description !== undefined) updateData.description = description;
    if (location !== undefined) updateData.location = location;
    if (status !== undefined) updateData.status = status;
    if (hourlyRate !== undefined) updateData.hourlyRate = parseFloat(hourlyRate);
    if (minHours !== undefined) updateData.minHours = parseInt(minHours);
    if (maxHours !== undefined) updateData.maxHours = parseInt(maxHours);
    if (amenities !== undefined) updateData.amenities = amenities;
    if (capacity !== undefined) updateData.capacity = parseInt(capacity);
    if (address !== undefined) updateData.address = address;
    if (includedGuests !== undefined) updateData.includedGuests = parseInt(includedGuests);
    if (extraGuestCharge !== undefined) updateData.extraGuestCharge = parseFloat(extraGuestCharge);
    if (minCapacity !== undefined) updateData.minCapacity = parseInt(minCapacity);
    if (size !== undefined) updateData.size = size;
    if (rules !== undefined) updateData.rules = rules;

    // Handle operating hours update
    if (operatingHours !== undefined) {
      const normalizedOperatingHours = normalizeOperatingHours(operatingHours);
      const validation = validateOperatingHours(normalizedOperatingHours);

      if (!validation.valid) {
        return res.status(400).json({
          error: "Invalid operating hours",
          details: validation.errors,
        });
      }

      updateData.operatingHours = normalizedOperatingHours;
    }

    const listing = await prisma.listing.update({
      where: { id: parseInt(id) },
      data: updateData,
      include: {
        images: true,
        host: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
      },
    });

    res.json(listing);
  } catch (error) {
    console.error("UPDATE LISTING ERROR:", error);
    res.status(400).json({ error: error.message });
  }
};

// ==========================================
// DELETE LISTING
// ==========================================

export const deleteListing = async (req, res) => {
  try {
    const { id } = req.params;
    const hostId = Number(req.user.userId);

    const existing = await prisma.listing.findFirst({
      where: { id: parseInt(id), hostId },
    });

    if (!existing) {
      return res.status(404).json({ error: "Listing not found" });
    }

    await prisma.listing.delete({
      where: { id: parseInt(id) },
    });

    res.json({ message: "Listing deleted successfully" });
  } catch (error) {
    console.error("DELETE LISTING ERROR:", error);
    res.status(500).json({ error: error.message });
  }
};

// ==========================================
// UPDATE STATUS
// ==========================================

export const updateStatus = async (req, res) => {
  try {
    const { id } = req.params;
    const { status } = req.body;
    const hostId = Number(req.user.userId);

    const existing = await prisma.listing.findFirst({
      where: { id: parseInt(id), hostId },
    });

    if (!existing) {
      return res.status(404).json({ error: "Listing not found" });
    }

    const listing = await prisma.listing.update({
      where: { id: parseInt(id) },
      data: { status },
      include: {
        images: true,
      },
    });

    res.json(listing);
  } catch (error) {
    console.error("UPDATE STATUS ERROR:", error);
    res.status(400).json({ error: error.message });
  }
};

// ==========================================
// DELETE IMAGE
// ==========================================

export const deleteImage = async (req, res) => {
  try {
    const { id } = req.params;
    const hostId = Number(req.user.userId);

    const image = await prisma.image.findUnique({
      where: { id: parseInt(id) },
      include: {
        listing: {
          select: { hostId: true },
        },
      },
    });

    if (!image) {
      return res.status(404).json({ error: "Image not found" });
    }

    if (image.listing.hostId !== hostId) {
      return res.status(403).json({ error: "Unauthorized" });
    }

    if (image.publicId) {
      await deleteFromCloudinary(image.publicId);
    }

    await prisma.image.delete({
      where: { id: parseInt(id) },
    });

    res.json({ message: "Image deleted successfully" });
  } catch (error) {
    console.error("DELETE IMAGE ERROR:", error);
    res.status(500).json({ error: error.message });
  }
};

// ==========================================
// SET COVER IMAGE
// ==========================================

export const setCoverImage = async (req, res) => {
  try {
    res.json({ message: "setCoverImage not implemented yet" });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

// ==========================================
// UPDATE DISCOUNTS
// ==========================================

export const updateDiscounts = async (req, res) => {
  try {
    const { id } = req.params;
    const hostId = Number(req.user.userId);
    const { durationDiscounts, bonusHoursOffer } = req.body;

    const listing = await prisma.listing.findFirst({
      where: { id: parseInt(id), hostId },
    });

    if (!listing) {
      return res.status(404).json({ error: "Listing not found" });
    }

    if (durationDiscounts?.tiers) {
      for (const tier of durationDiscounts.tiers) {
        if (!tier.minHours || tier.minHours < 1) {
          return res.status(400).json({ error: "Each tier must have minHours >= 1" });
        }
        if (!tier.discountPercent || tier.discountPercent < 1 || tier.discountPercent > 50) {
          return res.status(400).json({ error: "Discount must be 1-50%" });
        }
      }

      const hours = durationDiscounts.tiers.map((t) => t.minHours);
      if (new Set(hours).size !== hours.length) {
        return res.status(400).json({ error: "Duplicate minHours not allowed" });
      }
    }

    if (bonusHoursOffer) {
      if (!bonusHoursOffer.minHours || bonusHoursOffer.minHours < 1) {
        return res.status(400).json({ error: "Bonus minHours must be >= 1" });
      }
      if (!bonusHoursOffer.bonusHours || bonusHoursOffer.bonusHours < 1) {
        return res.status(400).json({ error: "Bonus hours must be >= 1" });
      }
    }

    const updated = await prisma.listing.update({
      where: { id: parseInt(id) },
      data: {
        durationDiscounts: durationDiscounts || null,
        bonusHoursOffer: bonusHoursOffer || null,
      },
      select: {
        id: true,
        durationDiscounts: true,
        bonusHoursOffer: true,
      },
    });

    res.json({ message: "Discounts updated", listing: updated });
  } catch (error) {
    console.error("Update discounts error:", error);
    res.status(500).json({ error: "Failed to update discounts" });
  }
};
// ============================================================================
// LISTING IMAGE CONTROLLERS
// ============================================================================

export async function uploadImages(req, res) {
  try {
    const listingId = Number(req.params.listingId);

    if (isNaN(listingId)) {
      return res.status(400).json({ error: "Invalid listing ID" });
    }

    const files = req.files;

    if (!files || files.length === 0) {
      return res.status(400).json({ error: "No files uploaded" });
    }

    // âœ… Upload files to Cloudinary
    const uploadPromises = files.map((file) =>
      uploadToCloudinary(file, null, listingId)
    );

    const uploadResults = await Promise.all(uploadPromises);
    
    // Pass full results (with secure_url and public_id) to service
    const images = await listingImageService.addImages(listingId, uploadResults);

    res.json({
      message: "Images uploaded successfully",
      images,
    });
  } catch (err) {
    console.error("UPLOAD IMAGES ERROR:", err);
    res.status(500).json({ error: err.message || "Server error" });
  }
}

// ... rest of the functions stay the same

/**
 * Get all images for a listing
 * GET /api/listings/:listingId/images
 */
export async function getImages(req, res) {
  try {
    const listingId = Number(req.params.listingId);

    if (isNaN(listingId)) {
      return res.status(400).json({ error: "Invalid listing ID" });
    }

    const images = await listingImageService.getImagesByListingId(listingId);
    res.json(images);
  } catch (err) {
    console.error("GET IMAGES ERROR:", err);
    res.status(500).json({ error: "Server error" });
  }
}

/**
 * Set an image as cover
 * PUT /api/listings/:listingId/images/:imageId/cover
 */
export async function setCoverImage(req, res) {
  try {
    const listingId = Number(req.params.listingId);
    const imageId = Number(req.params.imageId);

    if (isNaN(listingId) || isNaN(imageId)) {
      return res.status(400).json({ error: "Invalid ID" });
    }

    const image = await listingImageService.setCoverImage(listingId, imageId);
    res.json({
      message: "Cover image updated",
      image,
    });
  } catch (err) {
    console.error("SET COVER IMAGE ERROR:", err);
    res.status(400).json({ error: err.message || "Server error" });
  }
}

/**
 * Delete an image
 * DELETE /api/listings/:listingId/images/:imageId
 */
export async function deleteImage(req, res) {
  try {
    const listingId = Number(req.params.listingId);
    const imageId = Number(req.params.imageId);

    if (isNaN(listingId) || isNaN(imageId)) {
      return res.status(400).json({ error: "Invalid ID" });
    }

    await listingImageService.deleteImage(listingId, imageId);
    res.json({ message: "Image deleted successfully" });
  } catch (err) {
    console.error("DELETE IMAGE ERROR:", err);
    res.status(400).json({ error: err.message || "Server error" });
  }
}

/**
 * Reorder images
 * PUT /api/listings/:listingId/images/reorder
 */
export async function reorderImages(req, res) {
  try {
    const listingId = Number(req.params.listingId);
    const { imageIds } = req.body;

    if (isNaN(listingId)) {
      return res.status(400).json({ error: "Invalid listing ID" });
    }

    if (!Array.isArray(imageIds) || imageIds.length === 0) {
      return res.status(400).json({ error: "Image IDs array is required" });
    }

    const images = await listingImageService.reorderImages(listingId, imageIds);
    res.json({
      message: "Images reordered successfully",
      images,
    });
  } catch (err) {
    console.error("REORDER IMAGES ERROR:", err);
    res.status(400).json({ error: err.message || "Server error" });
  }
}